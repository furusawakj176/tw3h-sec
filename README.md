# なりすましを防ぎつつ匿名投票を実現する

本プロダクトの目的  
なりすましを防ぐ、匿名投票所の「受付」を作る  

背景  
ZKPを利用した匿名投票のプロダクトも色々リリースされているようですが、投票サイトにアクセスする時点でのなりすましという部分にはまだまだ課題があるようです。  
実証実験ではマイナンバーを使ったりKYC系のサービスと組み合わせる等で実現しているようですが、投票するたびに身分証明書の写真を送ったり、顔認証をしたりではあまりユーザビリティが良いとは思えません。  
これをNFTのレンタル機能を使ってもっとシンプルに解決できないか？と思い、考えてみました。  

ポイント  
・匿名投票システムはzkCREAMを使うことを想定しています  
・投票実施者は事前にウォレットの情報を含むKYC済みの有権者名簿を作成します  
・投票者は投票期間中のみ専用のNFTがレンタルされ、そのNFTの使用権があることを条件に匿名投票システムにアクセスすることが出来ます  
・一度名簿登録すると以降は何回投票が行われても透過的に証明が出来ます  
・投票者はガス代払わなくて良いようにしたい…  

## 使用したtech stacks
Solidity

## 使用したBlockchain
Ethereum（Goerli）

## deployしたContract
MyNFT-Rental.sol  
MyReturn-Token.sol

## application codeやその他のfile
フロント側は箱だけです。

## テスト手順
アカウントA：実施者  
アカウントB：投票者


コントラクト１：MyNFT-Rental (0xdc6Febc82718518156a6365ecCDfb6abDf9B65cC)  
https://thirdweb.com/goerli/0xdc6Febc82718518156a6365ecCDfb6abDf9B65cC/

コントラクト２：NFTReturn　（0x5b71a33A58D8D4D566b9cf241a3da8910676d378）  
https://thirdweb.com/goerli/0x5b71a33A58D8D4D566b9cf241a3da8910676d378/

***
手順１：アカウントAはコントラクト１のmint関数を使い、任意のIDとtokenURIでNFTをミントします  
手順２：アカウントAはコントラクト１のsetApprovalForAll関数を使い、コントラクト２のapprovedをtrueにします（既に実施済み）  
手順３：アカウントAはコントラクト１のrentOut関数を使い、手順１で作ったIDをアカウントBに対して任意の期間貸し出します  
手順４：アカウントAはコントラクト１のuserOf関数を使い、手順１で作ったIDの使用者がアカウントBになっていることを確認します  
手順５：アカウントBはコントラクト２のproxy関数を使い、destに"0xdc6Febc82718518156a6365ecCDfb6abDf9B65cC"、idに手順１で作ったIDをセットし実行します  
手順６：アカウントAはコントラクト１のuserOf関数を使い、手順１で作ったIDの使用者がゼロアドレスになっていることを確認します  

## 審査やテストのためにプロジェクトにアクセスする方法など
